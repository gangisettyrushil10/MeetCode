import matplotlib.pyplot as plt
import numpy as np
import librosa.display

class TrainingVisualizer:
    """
    Visualization tools for monitoring the training process
    and analyzing audio separation results.
    """
    def __init__(self, save_dir='./visualizations'):
        """
        Initialize visualizer with save directory.
        
        Args:
            save_dir: Directory to save visualization plots
        """
        self.save_dir = save_dir

    def plot_spectrogram(self, spectrogram, title='Spectrogram', save_path=None):
        """
        Plot a spectrogram.
        
        Args:
            spectrogram: Input spectrogram
            title: Plot title
            save_path: Path to save the plot (optional)
        """
        plt.figure(figsize=(10, 4))
        librosa.display.specshow(
            librosa.amplitude_to_db(spectrogram, ref=np.max),
            y_axis='log',
            x_axis='time'
        )
        plt.colorbar(format='%+2.0f dB')
        plt.title(title)
        
        if save_path:
            plt.savefig(save_path)
            plt.close()
        else:
            plt.show()

    def plot_training_progress(self, losses, metrics, save_path=None):
        """
        Plot training progress including loss and metrics.
        
        Args:
            losses: Dictionary of training losses
            metrics: Dictionary of evaluation metrics
            save_path: Path to save the plot (optional)
        """
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))
        
        # Plot losses
        for name, values in losses.items():
            ax1.plot(values, label=name)
        ax1.set_title('Training Losses')
        ax1.set_xlabel('Iteration')
        ax1.set_ylabel('Loss')
        ax1.legend()
        
        # Plot metrics
        for name, values in metrics.items():
            ax2.plot(values, label=name)
        ax2.set_title('Evaluation Metrics')
        ax2.set_xlabel('Epoch')
        ax2.set_ylabel('Score')
        ax2.legend()
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path)
            plt.close()
        else:
            plt.show()

    def plot_waveforms(self, original, predicted, target, save_path=None):
        """
        Plot original, predicted, and target waveforms for comparison.
        
        Args:
            original: Original mixture waveform
            predicted: Predicted separated waveform
            target: Target separated waveform
            save_path: Path to save the plot (optional)
        """
        plt.figure(figsize=(15, 9))
        
        # Plot original mixture
        plt.subplot(3, 1, 1)
        plt.plot(original)
        plt.title('Original Mixture')
        plt.xlabel('Time')
        plt.ylabel('Amplitude')
        
        # Plot predicted separation
        plt.subplot(3, 1, 2)
        plt.plot(predicted)
        plt.title('Predicted Separation')
        plt.xlabel('Time')
        plt.ylabel('Amplitude')
        
        # Plot target
        plt.subplot(3, 1, 3)
        plt.plot(target)
        plt.title('Target Separation')
        plt.xlabel('Time')
        plt.ylabel('Amplitude')
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path)
            plt.close()
        else:
            plt.show()

    def plot_separation_masks(self, masks, save_path=None):
        """
        Plot separation masks generated by the model.
        
        Args:
            masks: Dictionary of separation masks
            save_path: Path to save the plot (optional)
        """
        num_masks = len(masks)
        plt.figure(figsize=(15, 3 * num_masks))
        
        for idx, (name, mask) in enumerate(masks.items(), 1):
            plt.subplot(num_masks, 1, idx)
            librosa.display.specshow(mask, y_axis='log', x_axis='time')
            plt.colorbar(format='%+2.0f dB')
            plt.title(f'{name} Mask')
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path)
            plt.close()
        else:
            plt.show()

    def create_training_summary(self, model_name, train_history, save_path=None):
        """
        Create a comprehensive training summary plot.
        
        Args:
            model_name: Name of the model
            train_history: Dictionary containing training history
            save_path: Path to save the plot (optional)
        """
        fig = plt.figure(figsize=(15, 10))
        
        # Loss plot
        plt.subplot(2, 2, 1)
        plt.plot(train_history['train_loss'], label='Train')
        plt.plot(train_history['val_loss'], label='Validation')
        plt.title('Loss History')
        plt.xlabel('Epoch')
        plt.ylabel('Loss')
        plt.legend()
        
        # Accuracy plot
        plt.subplot(2, 2, 2)
        plt.plot(train_history['train_accuracy'], label='Train')
        plt.plot(train_history['val_accuracy'], label='Validation')
        plt.title('Accuracy History')
        plt.xlabel('Epoch')
        plt.ylabel('Accuracy')
        plt.legend()
        
        # Learning rate plot
        plt.subplot(2, 2, 3)
        plt.plot(train_history['learning_rate'])
        plt.title('Learning Rate')
        plt.xlabel('Epoch')
        plt.ylabel('LR')
        
        # Custom metrics plot
        plt.subplot(2, 2, 4)
        for metric_name, values in train_history['metrics'].items():
            plt.plot(values, label=metric_name)
        plt.title('Additional Metrics')
        plt.xlabel('Epoch')
        plt.ylabel('Value')
        plt.legend()
        
        plt.suptitle(f'Training Summary - {model_name}')
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path)
            plt.close()
        else:
            plt.show()